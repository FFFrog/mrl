## 1. `ld.so` 在加载主程序时的行为

- **加载所有直接和间接依赖库**：当主程序启动时，`ld.so` 会自动加载主程序的直接依赖库（由 `DT_NEEDED` 标签标识的库），并递归加载这些库的间接依赖。
- **符号加入全局符号表**：无论是直接依赖还是间接依赖，`ld.so` 都会将这些库的符号添加到全局符号表。这样主程序及其加载的所有库在解析符号时，都可以优先在全局符号表中找到所需的符号。

**注意**:
全局符号表只是一个逻辑概念，详情见附录

## 2. `dlopen` 加载库时的 `RTLD_GLOBAL` 和 `RTLD_LOCAL` 行为

- **`RTLD_GLOBAL`**：当使用 `dlopen` 加载库时，指定 `RTLD_GLOBAL` 标志不仅会将该库的符号添加到全局符号表，还会将其所有间接依赖库的符号也递归地添加到全局符号表。这确保了通过 `dlopen` 加载的库及其间接依赖的符号在全局范围内可见，方便后续符号解析。
- **`RTLD_LOCAL`**：如果使用 `RTLD_LOCAL` 加载库，则该库及其间接依赖库的符号不会加入全局符号表。

## 3. 符号解析顺序

无论库是通过主程序还是 `dlopen` 加载，符号解析顺序遵循以下逻辑：

- **全局符号表优先**：`ld.so` 首先会在全局符号表中查找符号，优先使用全局可见的符号。
- **库本地查找**：如果在全局符号表中未找到符号，`ld.so` 会在调用符号的库本身及其依赖中继续查找符号（经测试会递归查找，而不仅仅是直接依赖）。
- **解析失败**：如果以上查找都无法解析符号，则抛出未定义符号错误（`undefined symbol`）。

## 总结

- **主程序加载的所有直接和间接依赖库**的符号都会加入全局符号表。
- **`dlopen` 加载库时的 `RTLD_GLOBAL`** 会将该库及其所有间接依赖库的符号递归加入全局符号表，而 `RTLD_LOCAL` 则不会。
- **符号解析**遵循“全局符号表优先，本地符号表次之”的顺序，以确保解析的兼容性和灵活性。


## 附录

**并不存在一个物理上的、巨大的“全局哈希表”来存放所有库的所有符号。** 这种做法在设计上是低效且不灵活的。

### 核心数据结构：链接映射 (Link Map)

动态链接器 `ld.so` 在进程启动时，会在自己的内存中维护一个核心数据结构，通常称为**链接映射（Link Map）**。

1.  **它是一个链表**：这个 Link Map 本质上是一个**双向链表**。链表中的每一个\*\*节点（Node）\*\*都代表一个已经加载到内存中的 ELF 对象（包括主程序本身、所有被 `LD_PRELOAD` 的库、以及所有 `DT_NEEDED` 依赖库）。

2.  **节点包含的信息**：每个节点都像一个“图书馆索引卡”，记录了关于这个库的所有关键信息，包括：

      * 指向链表中上一个和下一个库节点的指针。
      * 该库被加载到虚拟内存中的**基地址（Base Address）**。
      * 一个指向该库ELF文件中 **动态节（Dynamic Section）** 的指针。这个节是关键，因为它包含了查找符号所需的所有元信息。
      * **最重要的**：从动态节可以找到指向该库**自己内部**的**动态符号表 (`.dynsym`)**、**动态字符串表 (`.dynstr`)** 以及**符号哈希表 (`.hash` 或 `.gnu.hash`)** 的指针。

**关键点**：每个库都“自备”了它自己的符号表和用于快速查找的哈希表。链接器不把它们合并，而是维护一个指向这些独立“账本”的列表。

### 符号查找的实际算法

当您的程序（通过 PLT/GOT 机制）第一次需要解析一个符号（比如 `malloc`）时，`ld.so` 会执行以下操作：

1.  **确定搜索范围**：对于一个普通的全局符号查找，搜索范围就是整个 Link Map 链表。

2.  **遍历链接映射链表**：`ld.so` 会**从头到尾线性地遍历**这个 Link Map 链表。这个链表的顺序至关重要，它是由加载顺序决定的：

      * `LD_PRELOAD` 的库永远在链表的最前面。
      * 其次是主程序本身。
      * 之后是按照我们之前讨论的\*\*深度优先（DFS）\*\*顺序加载的各个依赖库。

3.  **在每个库内部进行哈希查找**：对于链表中的**每一个库节点**，`ld.so` 会执行以下高效的内部查找：
    a. 它获取到这个库自己的符号哈希表（通常是 `.gnu.hash`，比旧的 `.hash` 更快）的地址。
    b. 它使用要查找的符号名（"malloc"）在这个**库专属的哈希表**中进行一次哈希计算和查找。
    c. **如果找到了**，哈希表会给出一个索引，`ld.so` 用此索引在其对应的 `.dynsym` 表中定位到该符号，再从 `.dynstr` 表中确认名称无误。**查找成功，整个过程立即停止。**
    d. **如果没找到**，`ld.so` 就会移动到 Link Map 链表的**下一个**节点，重复步骤 a、b、c。

4.  **最终结果**：

      * 如果在遍历完整个链表后，仍然没有找到该符号，`ld.so` 就会报告“undefined symbol”错误。
      * “先找到就先使用（first one wins）”的规则，正是这个**线性遍历链表**过程的自然结果。

### 图解这个过程

```
ld.so 维护的 Link Map (双向链表)

[ Head ] <--> [ Node for libasan.so ] <--> [ Node for PyTorch ] <--> [ Node for libjpeg.so ] <--> ...
                 |                         |                            |
                 |      +------------------+         +------------------+
                 |      |                          |
                 +----->+ 指向 libasan.so 自己的   +--> 指向 torch 自己的
                        | .dynsym, .dynstr,        |    .dynsym, .dynstr,
                        | .gnu.hash                |    .gnu.hash
                        +------------------+         +------------------+
```

`ld.so` 确实只维护**一个总的、包含所有已加载对象的 Link Map**。但它并不总是遍历整个链表。相反，它会为不同的库**定义不同的“搜索作用域列表”**。这个列表就是总 Link Map 的一个**有序子集**。

因此对于 `RTLD_LOCAL` 来说，相较于 `RTLD_GLOBAL` 来说，只是 **搜索作用域 (Search Scopes)** 不同；

### 总结


* **“全局符号表”是一个逻辑概念**。它的物理实现是一个**由各个库组成的、有优先级顺序的链表（Link Map）**。
* **查找过程是“顺着链表查”**。这是一个**线性遍历**，但每一步的内部查找都是**高效的哈希查找**。
* `RTLD_GLOBAL` 和 `RTLD_LOCAL` 标志的作用都是将被加载的库插入到这个全局的 Link Map 链表中，让它成为后续符号查找的一部分，区别在于这两者的 **搜索作用域** 不同而已；
